@JS()
library node_modules._types.d3_shape;

import "package:js/js.dart";
import "dart:html" show CanvasRenderingContext2D, Path2D;
import "package:func/func.dart";
import "d3-path.dart" show Path;

/// Type definitions for D3JS d3-shape module 1.0
/// Project: https://github.com/d3/d3-shape/
/// Definitions by: Tom Wanzek <https://github.com/tomwanzek>, Alex Ford <https://github.com/gustavderdrache>, Boris Yankov <https://github.com/borisyankov>
/// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
/// Last module patch version validated against: 1.0.4
/// -----------------------------------------------------------------------------------
/// Arc Generator
/// -----------------------------------------------------------------------------------
/// Interface corresponding to the minimum data type assumed by the accessor functions of  the Arc generator
@anonymous
@JS()
abstract class DefaultArcObject {
  /// Inner radius of arc.
  external num get innerRadius;
  external set innerRadius(num v);

  /// Outer radius of arc.
  external num get outerRadius;
  external set outerRadius(num v);

  /// Start angle of arc. The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  external num get startAngle;
  external set startAngle(num v);

  /// End angle of arc. The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  external num get endAngle;
  external set endAngle(num v);

  /// Pad angle of arcin radians.
  external num get padAngle;
  external set padAngle(num v);
  external factory DefaultArcObject(
      {num innerRadius,
      num outerRadius,
      num startAngle,
      num endAngle,
      num padAngle});
}

/// The arc generator produces a circular or annular sector, as in a pie or donut chart.
/// If the difference between the start and end angles (the angular span) is greater than τ, the arc generator will produce a complete circle or annulus.
/// If it is less than τ, arcs may have rounded corners and angular padding. Arcs are always centered at ⟨0,0⟩; use a transform (see: SVG, Canvas) to move the arc to a different position.
/// See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.
/// The first generic corresponds to the type of the "this" context within which the arc generator and its accessor functions will be invoked.
/// The second generic corresponds to the datum type for which the arc is to be generated.
@anonymous
@JS()
abstract class Arc<This, Datum> {
  /// Generates an arc for the given arguments.
  /// IMPORTANT: If the rendering context of the arc generator is null,
  /// then the arc is returned as a path data string.
  /// The "this" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.
  /// All arguments passed into this function, will be passed to the accessor functions of the generator.
  /*external String|Null call(This JS$this, Datum d, [dynamic args1, dynamic args2, dynamic args3, dynamic args4, dynamic args5]);*/
  /// Generates an arc for the given arguments.
  /// IMPORTANT: If the arc generator has been configured with a rendering context,
  /// then the arc is rendered to this context as a sequence of path method calls and this function returns void.
  /// The "this" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.
  /// All arguments passed into this function, will be passed to the accessor functions of the generator.
  /*external void call(This JS$this, Datum d,
    [dynamic args1,
    dynamic args2,
    dynamic args3,
    dynamic args4,
    dynamic args5]);*/
  external dynamic /*String|Null*/ call(
      /*This this*/ Datum d, List<dynamic> args);

  /// Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.
  /// To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments.
  /// The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2.
  /// Note that this is not the geometric center of the arc, which may be outside the arc;
  /// this method is merely a convenience for positioning labels.
  /// The method is invoked in the same "this" context as the generator was invoked in and
  /// receives the same arguments that are passed into the arc generator.
  external List<num> /*Tuple of <num,num>*/ centroid(Datum d,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Returns the current inner radius accessor, which defaults to a function returning the innerRadius property
  /// of the first argument passed into it.
  /*external (this: This, d: Datum, ...args: any[]) => number innerRadius();*/
  /// Sets the inner radius to the specified number and returns this arc generator.
  /// Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale.
  /// More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.
  /// A negative value is treated as zero.
  /*external Arc innerRadius(num radius);*/
  /// Sets the inner radius to the specified function and returns this arc generator.
  /// Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale.
  /// More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.
  /// A negative value is treated as zero.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc innerRadius((this: This, d: Datum, ...args: any[]) => number radius);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ innerRadius(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ radius]);

  /// Returns the current outer radius accessor, which defaults to a function returning the outerRadius property
  /// of the first argument passed into it.
  /*external (this: This, d: Datum, ...args: any[]) => number outerRadius();*/
  /// Sets the outer radius to the specified number and returns this arc generator.
  /// Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart,
  /// often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart.
  /// If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.
  /// A negative value is treated as zero.
  /*external Arc outerRadius(num radius);*/
  /// Sets the outer radius to the specified function and returns this arc generator.
  /// Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart,
  /// often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart.
  /// If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.
  /// A negative value is treated as zero.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc outerRadius((this: This, d: Datum, ...args: any[]) => number radius);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ outerRadius(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ radius]);

  /// Returns the current corner radius accessor, which defaults to a function returning a constant value of zero.
  /*external (this: This, d: Datum, ...args: any[]) => number cornerRadius();*/
  /// Sets the corner radius to the specified number and returns this arc generator.
  /// If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius.
  /// For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.
  /// The corner radius may not be larger than (outerRadius - innerRadius) / 2.
  /// In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect.
  /// This is occurs more often with the inner corners.
  /*external Arc cornerRadius(num radius);*/
  /// Sets the corner radius to the specified function and returns this arc generator.
  /// The corner radius may not be larger than (outerRadius - innerRadius) / 2.
  /// In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect.
  /// This is occurs more often with the inner corners.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc cornerRadius((this: This, d: Datum, ...args: any[]) => number radius);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ cornerRadius(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ radius]);

  /// Returns the current start angle accessor, which defaults to a function returning the startAngle property
  /// of the first argument passed into it.
  /*external (this: This, d: Datum, ...args: any[]) => number startAngle();*/
  /// Sets the start angle to the specified number and returns this arc generator.
  /// The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.
  /*external Arc startAngle(num angle);*/
  /// Sets the start angle to the specified function and returns this arc generator.
  /// The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc startAngle((this: This, d: Datum, ...args: any[]) => number angle);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ startAngle(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ angle]);

  /// Returns the current end angle accessor, which defaults to a function returning the endAngle property
  /// of the first argument passed into it.
  /*external (this: This, d: Datum, ...args: any[]) => number endAngle();*/
  /// Sets the end angle to the specified number and returns this arc generator.
  /// The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.
  /*external Arc endAngle(num angle);*/
  /// Sets the end angle to the specified function and returns this arc generator.
  /// The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc endAngle((this: This, d: Datum, ...args: any[]) => number angle);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ endAngle(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ angle]);

  /// Returns the current pad angle accessor, which defaults to a function returning the padAngle property
  /// of the first argument passed into it, or false if no data are passed in or the property is not defined.
  /*external (this: This, d: Datum, ...args: any[]) => number padAngle();*/
  /// Sets the pad angle to the specified number and returns this arc generator.
  /// The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius * padAngle. This distance is subtracted equally from the start and end of the arc.
  /// If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ τ, the pad angle is ignored. If the inner radius or angular span is small relative to the pad angle,
  /// it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector.
  /// For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive).
  /// The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding.
  /// For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels.
  /// Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value;
  /// see pie.padAngle. See the pie padding animation for illustration.
  /// If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.
  /*external Arc padAngle(num angle);*/
  /// Sets the pad angle to the specified function and returns this arc generator.
  /// The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius * padAngle. This distance is subtracted equally from the start and end of the arc.
  /// If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ τ, the pad angle is ignored. If the inner radius or angular span is small relative to the pad angle,
  /// it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector.
  /// For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive).
  /// The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding.
  /// For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels.
  /// Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value;
  /// see pie.padAngle. See the pie padding animation for illustration.
  /// If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc padAngle((this: This, d: Datum, ...args: any[]) => number angle);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ padAngle(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ angle]);

  /// Returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius * innerRadius + outerRadius * outerRadius).
  /*external (this: This, d: Datum, ...args: any[]) => number|Null padRadius();*/
  /// Sets the pad radius to null indicating that the pad radius should be automatically computed as sqrt(innerRadius * innerRadius + outerRadius * outerRadius), and returns this arc generator.
  /// The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius * padAngle.
  /*external Arc padRadius(Null radius);*/
  /// Sets the pad radius to the specified number, and returns this arc generator.
  /// The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius * padAngle.
  /*external Arc padRadius(num radius);*/
  /// Sets the pad radius to the specified function, and returns this arc generator.
  /// receives the same arguments that were passed into the arc generator.
  /*external Arc padRadius((this: This, d: Datum, ...args: any[]) => number radius);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Arc*/ padRadius(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ radius]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this arc generator.
  /// If the context is not null, then the generated arc is rendered to this context as a sequence of path method calls.
  /*external Arc context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this arc generator.
  /// A path data string representing the generated arc will be returned when the generator is invoked with data.
  /*external Arc context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|Arc*/ context(
      [CanvasRenderingContext2D context]);
}

/// Constructs a new arc generator with the default settings.
/// Ensure that the accessors used with the arc generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external Arc<dynamic, DefaultArcObject> arc();*/
/// Constructs a new arc generator with the default settings.
/// Ensure that the accessors used with the arc generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic corresponds to the datum type representing a arc.
/*external Arc<dynamic,Datum> arc<Datum>();*/
/// Constructs a new arc generator with the default settings.
/// Ensure that the accessors used with the arc generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The first generic corresponds to the type of the "this" context within which the arc generator and its accessor functions will be invoked.
/// The second generic corresponds to the datum type representing a arc.
/*external Arc<This,Datum> arc<This, Datum>();*/
@JS()
external Arc /*Arc<dynamic,DefaultArcObject>|Arc<dynamic,Datum>|Arc<This,Datum>*/ arc/*<Datum, This>*/();

/// -----------------------------------------------------------------------------------
/// Pie Generator
/// -----------------------------------------------------------------------------------
/// Element of the Arc Datums Array created by invoking the Pie generator.
/// The generic refers to the data type of an element in the input array passed into the Pie generator.
@anonymous
@JS()
abstract class PieArcDatum<T> {
  /// The input datum; the corresponding element in the input data array of the Pie generator
  external T get data;
  external set data(T v);

  /// The numeric value of the arc.
  external num get value;
  external set value(num v);

  /// The zero-based sorted index of the arc.
  external num get index;
  external set index(num v);

  /// The start angle of the arc. If the pie generator was configured to be used for the arc generator, than the units are in radians with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  external num get startAngle;
  external set startAngle(num v);

  /// The end angle of the arc. If the pie generator was configured to be used for the arc generator, than the units are in radians with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  external num get endAngle;
  external set endAngle(num v);

  /// The pad angle of the arc. If the pie generator was configured to be used for the arc generator, than the units are in radians.
  external num get padAngle;
  external set padAngle(num v);
  external factory PieArcDatum(
      {T data,
      num value,
      num index,
      num startAngle,
      num endAngle,
      num padAngle});
}

/// The pie generator does not produce a shape directly, but instead computes the necessary angles to represent a tabular dataset as a pie or donut chart;
/// these angles can then be passed to an arc generator.
/// The first generic corresponds to the type of the "this" context within which the pie generator and its accessor functions will be invoked.
/// The second generic refers to the data type of an element in the input array passed into the Pie generator.
@anonymous
@JS()
abstract class Pie<This, Datum> {
  /// Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles.
  /// Any additional arguments are arbitrary; they are simply propagated to the pie generator’s accessor functions along with the this object.
  /// The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data.
  /// This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors.
  /// The angular units are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,
  /// you should specify angles in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  external List<PieArcDatum<Datum>> call(/*This this*/ List<Datum> data,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Returns the current value accessor, which defaults to a function returning the first argument passed into it.
  /// The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf.
  /*external Func3<Datum, num, List<Datum>, num> value();*/
  /// Sets the value accessor to use the specified constant number and returns this pie generator.
  /*external Pie value(num value);*/
  /// Sets the value accessor to use the specified function and returns this pie generator.
  /// When a pie is generated, the value accessor will be invoked for each element in the input data array.
  /// The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf.
  /// If your data are not simply numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum.
  /// It returns a numeric value.
  /*external Pie value(num value(Datum d, num i, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Pie*/ value(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ value]);

  /// Returns the current data comparator, which defaults to null.
  /*external Func2<Datum, Datum, num>|Null sort();*/
  /// Sets the data comparator to the specified function and returns this pie generator.
  /// If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.
  /// Otherwise, the data is sorted according to the data comparator, and the resulting order is used. Setting the data comparator implicitly sets the value comparator to null.
  /// Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc.
  /// The first arc starts at the start angle and the last arc ends at the end angle.
  /// If the arc for a should be before the arc for b, then the comparator must return a number less than zero;
  /// if the arc for a should be after the arc for b, then the comparator must return a number greater than zero;
  /// returning zero means that the relative order of a and b is unspecified.
  /*external Pie sort(num comparator(Datum a, Datum b));*/
  /// Sets the data comparator to null and returns this pie generator.
  /// If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.
  /*external Pie sort(Null comparator);*/
  external dynamic /*Func2<Datum, Datum, num>|Pie*/ sort(
      [num comparator(Datum a, Datum b)]);

  /// Returns the current value comparator, which defaults to descending value.
  /*external Func2<num, num, num>|Null sortValues();*/
  /// Sets the value comparator to the specified function and returns this pie generator.
  /// If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.
  /// Otherwise, the data is sorted according to the data comparator, and the resulting order is used.
  /// Setting the value comparator implicitly sets the data comparator to null.
  /// Sorting does not affect the order of the generated arc array which is always in the same order as the input data array;
  /// it merely affects the computed angles of each arc. The first arc starts at the start angle and the last arc ends at the end angle.
  /// If the arc for a should be before the arc for b, then the comparator must return a number less than zero;
  /// if the arc for a should be after the arc for b, then the comparator must return a number greater than zero; returning zero means that the relative order of a and b is unspecified.
  /*external Pie sortValues(num comparator(num a, num b));*/
  /// Sets the value comparator to null and returns this pie generator.
  /// If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.
  /*external Pie sortValues(Null comparator);*/
  external dynamic /*Func2<num, num, num>|Pie*/ sortValues(
      [num comparator(num a, num b)]);

  /// Returns the current start angle accessor, which defaults to a function returning a constant zero.
  /*external (this: This, data: Datum[], ...args: any[]) => number startAngle();*/
  /// Sets the overall start angle of the pie to the specified number and returns this pie generator.
  /// The default start angle is zero.
  /// The start angle here means the overall start angle of the pie, i.e., the start angle of the first arc.
  /// The start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,
  /// you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /*external Pie startAngle(num angle);*/
  /// Sets the overall start angle of the pie to the specified function and returns this pie generator.
  /// The default start angle is zero.
  /// The start angle here means the overall start angle of the pie, i.e., the start angle of the first arc.
  /// The start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,
  /// you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /*external Pie startAngle((this: This, data: Datum[], ...args: any[]) => number angle);*/
  external dynamic /*(this: This, data: Datum[], ...args: any[]) => number|Pie*/ startAngle(
      [dynamic /*num|(this: This, data: Datum[], ...args: any[]) => number*/ angle]);

  /// Returns the current end angle accessor, which defaults to a function returning a constant 2*pi.
  /*external (this: This, data: Datum[], ...args: any[]) => number endAngle();*/
  /// Sets the overall end angle of the pie to the specified number and returns this pie generator.
  /// The default end angle is 2*pi.
  /// The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,
  /// you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.
  /*external Pie endAngle(num angle);*/
  /// Sets the overall end angle of the pie to the specified function and returns this pie generator.
  /// The default end angle is 2*pi.
  /// The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc.
  /// The end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,
  /// you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.
  /// The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.
  /*external Pie endAngle((this: This, data: Datum[], ...args: any[]) => number angle);*/
  external dynamic /*(this: This, data: Datum[], ...args: any[]) => number|Pie*/ endAngle(
      [dynamic /*num|(this: This, data: Datum[], ...args: any[]) => number*/ angle]);

  /// Returns the current pad angle accessor, which defaults to a function returning a constant zero.
  /*external (this: This, data: Datum[], ...args: any[]) => number padAngle();*/
  /// Sets the pad angle to the specified number and returns this pie generator.
  /// The pad angle here means the angular separation between each adjacent arc.
  /// The total amount of padding reserved is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|;
  /// the remaining space is then divided proportionally by value such that the relative area of each arc is preserved.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator, you should specify an angle in radians.
  /*external Pie padAngle(num angle);*/
  /// Sets the pad angle to the specified function and returns this pie generator.
  /// The pad angle here means the angular separation between each adjacent arc.
  /// The total amount of padding reserved is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|;
  /// the remaining space is then divided proportionally by value such that the relative area of each arc is preserved.
  /// The pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.
  /// The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator, you should specify an angle in radians.
  /*external Pie padAngle((this: This, data: Datum[], ...args: any[]) => number angle);*/
  external dynamic /*(this: This, data: Datum[], ...args: any[]) => number|Pie*/ padAngle(
      [dynamic /*num|(this: This, data: Datum[], ...args: any[]) => number*/ angle]);
}

/// Constructs a new pie generator with the default settings.
/// Ensure that the accessors used with the pie generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external Pie<dynamic,num|{ valueOf(): number }> pie();*/
/// Constructs a new pie generator with the default settings.
/// Ensure that the accessors used with the pie generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic refers to the data type of an element in the input array passed into the Pie generator.
/*external Pie<dynamic,Datum> pie<Datum>();*/
/// Constructs a new pie generator with the default settings.
/// Ensure that the accessors used with the pie generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The first generic corresponds to the type of the "this" context within which the pie generator and its accessor functions will be invoked.
/// The second generic refers to the data type of an element in the input array passed into the Pie generator.
/*external Pie<This,Datum> pie<This, Datum>();*/
@JS()
external Pie<dynamic,
    dynamic> /*Pie<dynamic,num|{ valueOf(): number }>|Pie<dynamic,Datum>|Pie<This,Datum>*/ pie/*<Datum, This>*/();

/// -----------------------------------------------------------------------------------
/// Line Generators
/// -----------------------------------------------------------------------------------
/// The line generator produces a spline or polyline, as in a line chart.
/// Lines also appear in many other visualization types, such as the links in hierarchical edge bundling.
/// The generic refers to the data type of an element in the input array passed into the line generator.
@anonymous
@JS()
abstract class Line<Datum> {
  /// Generates a line for the given array of data. Depending on this line generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the line generator.
  /// IMPORTANT: If the rendering context of the line generator is null,
  /// then the line is returned as a path data string.
  /*external String|Null call(List<Datum> data);*/
  /// Generates a line for the given array of data. Depending on this line generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the line generator.
  /// IMPORTANT: If the line generator has been configured with a rendering context,
  /// then the line is rendered to this context as a sequence of path method calls and this function returns void.
  /*external void call(List<Datum> data);*/
  external dynamic /*String|Null*/ call(List<Datum> data);

  /// Returns the current x-coordinate accessor function, which defaults to a function returning first element of a two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> x();*/
  /// Sets the x accessor to the specified number and returns this line generator.
  /*external Line x(num x);*/
  /// Sets the x accessor to the specified function and returns this line generator.
  /// When a line is generated, the x accessor will be invoked for each defined element in the input data array.
  /// The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,
  /// then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Line x(num x(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Line*/ x(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ x]);

  /// Returns the current y-coordinate accessor function, which defaults to a function returning second element of a two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> y();*/
  /// Sets the y accessor to the specified number and returns this line generator.
  /*external Line y(num y);*/
  /// Sets the y accessor to the specified function and returns this line generator.
  /// When a line is generated, the y accessor will be invoked for each defined element in the input data array.
  /// The default y accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,
  /// then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Line y(num y(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Line*/ y(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ y]);

  /// Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.
  /*external Func3<Datum, num, List<Datum>, bool> defined();*/
  /// Sets the defined accessor to the specified boolean and returns this line generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a line is generated, the defined accessor will be invoked for each element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the x and y accessors will subsequently be evaluated and the point will be added to the current line segment.
  /// Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.
  /// As a result, the generated line may have several discrete segments.
  /// Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.
  /*external Line defined(bool defined);*/
  /// Sets the defined accessor to the specified function and returns this line generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a line is generated, the defined accessor will be invoked for each element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the x and y accessors will subsequently be evaluated and the point will be added to the current line segment.
  /// Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.
  /// As a result, the generated line may have several discrete segments.
  /// Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Line defined(bool defined(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, bool>|Line*/ defined(
      [dynamic /*bool|Func3<Datum, num, List<Datum>, bool>*/ defined]);

  /// Returns the current curve factory, which defaults to curveLinear.
  /*external CurveFactory|CurveFactoryLineOnly curve();*/
  /// Returns the current curve factory, which defaults to curveLinear.
  /// The generic allows to cast the curve factory to a specifc type, if known.
  /*external C curve<C extends CurveFactory|CurveFactoryLineOnly>();*/
  /// Sets the curve factory and returns this line generator.
  /*external Line curve(CurveFactory|CurveFactoryLineOnly curve);*/
  external dynamic /*CurveFactory|CurveFactoryLineOnly|C|Line*/ curve/*<C>*/(
      [Function /*CurveFactory|CurveFactoryLineOnly*/ curve]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this line generator.
  /// If the context is not null, then the generated line is rendered to this context as a sequence of path method calls.
  /*external Line context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this line generator.
  /// A path data string representing the generated line will be returned when the generator is invoked with data.
  /*external Line context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|Line*/ context(
      [CanvasRenderingContext2D context]);
}

/// Constructs a new line generator with the default settings.
/// Ensure that the accessors used with the line generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external Line<Tuple of <num,num>> line();*/
/// Constructs a new line generator with the default settings.
/// Ensure that the accessors used with the line generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic refers to the data type of an element in the input array passed into the line generator.
/*external Line<Datum> line<Datum>();*/
@JS()
external Line /*Line<Tuple of <num,num>>|Line<Datum>*/ line/*<Datum>*/();

/// The radial line generator produces a spline or polyline, as in a line chart.
/// A radial line generator is equivalent to the standard Cartesian line generator,
/// except the x and y accessors are replaced with angle and radius accessors.
/// Radial lines are always positioned relative to ⟨0,0⟩; use a transform (see: SVG, Canvas) to change the origin.
/// The generic refers to the data type of an element in the input array passed into the line generator.
@anonymous
@JS()
abstract class RadialLine<Datum> {
  /// Generates a radial line for the given array of data. Depending on this radial line generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the line generator.
  /// IMPORTANT: If the rendering context of the radial line generator is null,
  /// then the radial line is returned as a path data string.
  /*external String|Null call(List<Datum> data);*/
  /// Generates a radial line for the given array of data. Depending on this radial line generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the radial line generator.
  /// IMPORTANT: If the radial line generator has been configured with a rendering context,
  /// then the radial line is rendered to this context as a sequence of path method calls and this function returns void.
  /*external void call(List<Datum> data);*/
  external dynamic /*String|Null*/ call(List<Datum> data);

  /// Returns the current angle accessor function, which defaults to a function returning first element of a two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> angle();*/
  /// Sets the angle accessor to the specified number and returns this radial line generator.
  /*external RadialLine angle(num angle);*/
  /// Sets the angle accessor to the specified function and returns this radial line generator.
  /// When a radial line is generated, the angle accessor will be invoked for each defined element in the input data array.
  /// The default angle accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,
  /// then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialLine angle(num angle(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialLine*/ angle(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ angle]);

  /// Returns the current radius accessor function, which defaults to a function returning second element of a two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> radius();*/
  /// Sets the radius accessor to the specified number and returns this radial line generator.
  /*external RadialLine radius(num radius);*/
  /// Sets the radius accessor to the specified function and returns this radial line generator.
  /// When a radial line is generated, the radius accessor will be invoked for each defined element in the input data array.
  /// The default radius accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,
  /// then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialLine radius(num radius(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialLine*/ radius(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ radius]);

  /// Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.
  /*external Func3<Datum, num, List<Datum>, bool> defined();*/
  /// Sets the defined accessor to the specified boolean and returns this radial line generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a radial line is generated, the defined accessor will be invoked for each element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the angle and radius accessors will subsequently be evaluated and the point will be added to the current radial line segment.
  /// Otherwise, the element will be skipped, the current radial line segment will be ended, and a new radial line segment will be generated for the next defined point.
  /// As a result, the generated radial line may have several discrete segments.
  /// Note that if a radial line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.
  /*external RadialLine defined(bool defined);*/
  /// Sets the defined accessor to the specified function and returns this radial line generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a radial line is generated, the defined accessor will be invoked for each element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the angle and radius accessors will subsequently be evaluated and the point will be added to the current radial line segment.
  /// Otherwise, the element will be skipped, the current radial line segment will be ended, and a new radial line segment will be generated for the next defined point.
  /// As a result, the generated radial line may have several discrete segments.
  /// Note that if a radial line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialLine defined(bool defined(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, bool>|RadialLine*/ defined(
      [dynamic /*bool|Func3<Datum, num, List<Datum>, bool>*/ defined]);

  /// Returns the current curve factory, which defaults to curveLinear.
  /*external CurveFactory|CurveFactoryLineOnly curve();*/
  /// Returns the current curve factory, which defaults to curveLinear.
  /// The generic allows to cast the curve factory to a specifc type, if known.
  /*external C curve<C extends CurveFactory|CurveFactoryLineOnly>();*/
  /// Sets the curve factory and returns this radial line generator.
  /// Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y,
  /// which is typically untrue of radial lines.
  /*external RadialLine curve(CurveFactory|CurveFactoryLineOnly curve);*/
  external dynamic /*CurveFactory|CurveFactoryLineOnly|C|RadialLine*/ curve/*<C>*/(
      [Function /*CurveFactory|CurveFactoryLineOnly*/ curve]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this radial line generator.
  /// If the context is not null, then the generated radial line is rendered to this context as a sequence of path method calls.
  /*external RadialLine context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this radial line generator.
  /// A path data string representing the generated radial line will be returned when the generator is invoked with data.
  /*external RadialLine context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|RadialLine*/ context(
      [CanvasRenderingContext2D context]);
}

/// Constructs a new radial line generator with the default settings.
/// Ensure that the accessors used with the radial line generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external RadialLine<Tuple of <num,num>> radialLine();*/
/// Constructs a new radial line generator with the default settings.
/// Ensure that the accessors used with the radial line generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic refers to the data type of an element in the input array passed into the radial line generator.
/*external RadialLine<Datum> radialLine<Datum>();*/
@JS()
external RadialLine /*RadialLine<Tuple of <num,num>>|RadialLine<Datum>*/ radialLine/*<Datum>*/();

/// -----------------------------------------------------------------------------------
/// Area Generators
/// -----------------------------------------------------------------------------------
/// The area generator produces an area, as in an area chart. An area is defined by two bounding lines, either splines or polylines.
/// Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero.
/// The first line (the topline) is defined by x1 and y1 and is rendered first; the second line (the baseline) is defined by x0 and y0 and is rendered second, with the points in reverse order.
/// With a curveLinear curve, this produces a clockwise polygon.
/// The generic refers to the data type of an element in the input array passed into the area generator.
@anonymous
@JS()
abstract class Area<Datum> {
  /// Generates an area for the given array of data. Depending on this area generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the area generator.
  /// IMPORTANT: If the rendering context of the area generator is null,
  /// then the area is returned as a path data string.
  /*external String|Null call(List<Datum> data);*/
  /// Generates an area for the given array of data. Depending on this area generator’s associated curve,
  /// the given input data may need to be sorted by x-value before being passed to the area generator.
  /// IMPORTANT: If the area generator has been configured with a rendering context,
  /// then the area is rendered to this context as a sequence of path method calls and this function returns void.
  /*external void call(List<Datum> data);*/
  external dynamic /*String|Null*/ call(List<Datum> data);

  /// Returns the current x0 accessor. The default x0 accessor is a function returning the first element of a
  /// two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> x();*/
  /// Sets x0 to a constant number x and x1 to null and returns this area generator.
  /// Setting x1 to null indicates that the previously-computed x0 value should be reused for the x1 value.
  /*external Area x(num x);*/
  /// Sets x0 to the specified function x and x1 to null and returns this area generator.
  /// The default x0 accessor assumes that the input data are two-element arrays of numbers and returns the first element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area x(num x(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ x(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ x]);

  /// Returns the current x0 accessor. The default x0 accessor is a function returning the first element of a
  /// two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> x0();*/
  /// Sets x0 to a constant number and returns this area generator.
  /*external Area x0(num x);*/
  /// Sets x0 to the specified function and returns this area generator.
  /// The default x0 accessor assumes that the input data are two-element arrays of numbers and returns the first element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area x0(num x(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ x0(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ x]);

  /// Returns the current x1 accessor, which defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value.
  /*external Func3<Datum, num, List<Datum>, num>|Null x1();*/
  /// Sets x1 to null and returns this area generator.
  /// Setting x1 to null indicates that the previously-computed x0 value should be reused for the x1 value.
  /*external Area x1(Null x);*/
  /// Sets x1 to a constant number and returns this area generator.
  /*external Area x1(num x);*/
  /// Sets x1 to the specified function and returns this area generator.
  /// The default x1 accessor is null, indicating that the previously-computed x0 value should be reused for the x1 value.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area x1(num x(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ x1(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ x]);

  /// Returns the current y0 accessor. The default y0 accessor is a function returning a constant value of zero.
  /*external Func3<Datum, num, List<Datum>, num> y();*/
  /// Sets y0 to a constant number y and y1 to null and returns this area generator.
  /// Setting y1 to null indicates that the previously-computed y0 value should be reused for the y1 value.
  /*external Area y(num y);*/
  /// Sets y0 to the accessor function y and y1 to null and returns this area generator.
  /// The default y0 accessor returns a constant value of zero.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area y(num y(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ y(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ y]);

  /// Returns the current y0 accessor. The default y0 accessor is a function a constant value of zero.
  /*external Func3<Datum, num, List<Datum>, num> y0();*/
  /// Sets y0 to a constant number and returns this area generator.
  /*external Area y0(num y);*/
  /// Sets y0 to the specified function and returns this area generator.
  /// The default y0 accessor is a function which returns a constant value of zero.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area y0(num y(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ y0(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ y]);

  /// Returns the current y1 accessor or null. The default y1 accessor is a function returning the second element of a
  /// two-element array of numbers.
  /// If the y1 accessor is null, the previously-computed y0 value is reused for the y1 value.
  /*external Func3<Datum, num, List<Datum>, num>|Null y1();*/
  /// Sets y1 to null and returns this area generator.
  /// Setting y1 to null indicates that the previously-computed y0 value should be reused for the y1 value.
  /*external Area y1(Null y);*/
  /// Sets y1 to a constant number and returns this area generator.
  /*external Area y1(num y);*/
  /// Sets y1 to the specified function and returns this area generator.
  /// The default y1 accessor assumes that the input data are two-element arrays of numbers and returns the second element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area y1(num y(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|Area*/ y1(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ y]);

  /// Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.
  /*external Func3<Datum, num, List<Datum>, bool> defined();*/
  /// Sets the defined accessor to the specified boolean and returns this area generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment.
  /// Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.
  /// As a result, the generated area may have several discrete segments.
  /// Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points
  /*external Area defined(bool defined);*/
  /// Sets the defined accessor to the specified function and returns this area generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element), the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment.
  /// Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.
  /// As a result, the generated area may have several discrete segments.
  /// Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external Area defined(bool defined(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, bool>|Area*/ defined(
      [dynamic /*bool|Func3<Datum, num, List<Datum>, bool>*/ defined]);

  /// Returns the current curve factory, which defaults to curveLinear.
  /*external CurveFactory curve();*/
  /// Returns the current curve factory, which defaults to curveLinear.
  /// The generic allows to cast the curve factory to a specifc type, if known.
  /*external C curve<C extends CurveFactory>();*/
  /// Sets the curve factory and returns this area generator.
  /*external Area curve(CurveFactory curve);*/
  external dynamic /*CurveFactory|C|Area*/ curve/*<C extends CurveFactory>*/(
      [CurveFactory curve]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this area generator.
  /// If the context is not null, then the generated area is rendered to this context as a sequence of path method calls.
  /*external Area context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this area generator.
  /// A path data string representing the generated area will be returned when the generator is invoked with data.
  /*external Area context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|Area*/ context(
      [CanvasRenderingContext2D context]);

  /// Returns a new line generator that has this area generator’s current defined accessor, curve and context.
  /// The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.
  external Line<Datum> lineX0();

  /// Returns a new line generator that has this area generator’s current defined accessor, curve and context.
  /// The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.
  external Line<Datum> lineY0();

  /// Returns a new line generator that has this area generator’s current defined accessor, curve and context.
  /// The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.
  external Line<Datum> lineX1();

  /// Returns a new line generator that has this area generator’s current defined accessor, curve and context.
  /// The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.
  external Line<Datum> lineY1();
}

/// Constructs a new area generator with the default settings.
/// Ensure that the accessors used with the area generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external Area<Tuple of <num,num>> area();*/
/// Constructs a new area generator with the default settings.
/// Ensure that the accessors used with the area generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic refers to the data type of an element in the input array passed into the area generator.
/*external Area<Datum> area<Datum>();*/
@JS()
external Area /*Area<Tuple of <num,num>>|Area<Datum>*/ area/*<Datum>*/();

/// A radial area generator.
/// A radial area generator is equivalent to the standard Cartesian area generator,
/// except the x and y accessors are replaced with angle and radius accessors.
/// Radial areas are always positioned relative to ⟨0,0⟩; use a transform (see: SVG, Canvas) to change the origin.
/// The generic refers to the data type of an element in the input array passed into the area generator.
@anonymous
@JS()
abstract class RadialArea<Datum> {
  /// Generates a radial area for the given array of data.
  /// IMPORTANT: If the rendering context of the radial area generator is null,
  /// then the radial area is returned as a path data string.
  /*external String|Null call(List<Datum> data);*/
  /// Generates a radial area for the given array of data.
  /// IMPORTANT: If the radial area generator has been configured with a rendering context,
  /// then the radial area is rendered to this context as a sequence of path method calls and this function returns void.
  /*external void call(List<Datum> data);*/
  external dynamic /*String|Null*/ call(List<Datum> data);

  /// Returns the current startAngle accessor. The default startAngle accessor is a function returning the first element of a
  /// two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> angle();*/
  /// Sets startAngle to a constant number angle and endAngle to null and returns this radial area generator.
  /// Setting endAngle to null indicates that the previously-computed startAngle value should be reused for the endAngle value.
  /*external RadialArea angle(num angle);*/
  /// Sets startAngle to the specified function angle and endAngle to null and returns this radial area generator.
  /// The default startAngle accessor assumes that the input data are two-element arrays of numbers and returns the first element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// The accessor will be invoked for each defined element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea angle(num angle(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ angle(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ angle]);

  /// Returns the current startAngle accessor. The default startAngle accessor is a function returning the first element of a
  /// two-element array of numbers.
  /*external Func3<Datum, num, List<Datum>, num> startAngle();*/
  /// Sets startAngle to a constant number and returns this radial area generator.
  /*external RadialArea startAngle(num angle);*/
  /// Sets startAngle to the specified function and returns this radial area generator.
  /// The default startAngle accessor assumes that the input data are two-element arrays of numbers and returns the first element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// The accessor will be invoked for each defined element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea startAngle(num angle(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ startAngle(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ angle]);

  /// Returns the current endAngle accessor, which defaults to null, indicating that the previously-computed startAngle value should be reused for the endAngle value.
  /*external Func3<Datum, num, List<Datum>, num>|Null endAngle();*/
  /// Sets endAngle to null and returns this radial area generator.
  /// Setting endAngle to null indicates that the previously-computed startAngle value should be reused for the endAngle value.
  /*external RadialArea endAngle(Null angle);*/
  /// Sets endAngle to a constant number and returns this radial area generator.
  /*external RadialArea endAngle(num angle);*/
  /// Sets endAngle to the specified function and returns this radial area generator.
  /// The default endAngle accessor is null, indicating that the previously-computed startAngle value should be reused for the endAngle value.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// The accessor will be invoked for each defined element in the input data array,
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea endAngle(num angle(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ endAngle(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ angle]);

  /// Returns the current innerRadius accessor. The default innerRadius accessor is a function returning a constant value of zero.
  /*external Func3<Datum, num, List<Datum>, num> radius();*/
  /// Sets innerRadius to a constant number radius and outerRadius to null and returns this radial area generator.
  /// Setting outerRadius to null indicates that the previously-computed innerRadius value should be reused for the outerRadius value.
  /*external RadialArea radius(num radius);*/
  /// Sets innerRadius to the accessor function radius and outerRadius to null and returns this radial area generator.
  /// The default innerRadius accessor returns a constant value of zero.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea radius(num radius(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ radius(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ radius]);

  /// Returns the current innerRadius accessor. The default innerRadius accessor is a function a constant value of zero.
  /*external Func3<Datum, num, List<Datum>, num> innerRadius();*/
  /// Sets innerRadius to a constant number and returns this radial area generator.
  /*external RadialArea innerRadius(num radius);*/
  /// Sets innerRadius to the specified function and returns this radial area generator.
  /// The default innerRadius accessor is a function which returns a constant value of zero.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea innerRadius(
    num radius(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ innerRadius(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ radius]);

  /// Returns the current outerRadius accessor or null. The default outerRadius accessor is a function returning the second element of a
  /// two-element array of numbers.
  /// If the outerRadius accessor is null, the previously-computed innerRadius value is reused for the outerRadius value.
  /*external Func3<Datum, num, List<Datum>, num>|Null outerRadius();*/
  /// Sets outerRadius to null and returns this radial area generator.
  /// Setting outerRadius to null indicates that the previously-computed innerRadius value should be reused for the outerRadius value.
  /*external RadialArea outerRadius(Null radius);*/
  /// Sets outerRadius to a constant number and returns this radial area generator.
  /*external RadialArea outerRadius(num radius);*/
  /// Sets outerRadius to the specified function and returns this radial area generator.
  /// The default outerRadius accessor assumes that the input data are two-element arrays of numbers and returns the second element.
  /// If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea outerRadius(
    num radius(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, num>|RadialArea*/ outerRadius(
      [dynamic /*num|Func3<Datum, num, List<Datum>, num>*/ radius]);

  /// Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.
  /*external Func3<Datum, num, List<Datum>, bool> defined();*/
  /// Sets the defined accessor to the specified boolean and returns this radial area generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a radial area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the startAngle, endAngle, innerRadius and outerRadius accessors will subsequently be evaluated and the point will be added to the current area segment.
  /// Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.
  /// As a result, the generated area may have several discrete segments.
  /// Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points
  /*external RadialArea defined(bool defined);*/
  /// Sets the defined accessor to the specified function and returns this radial area generator.
  /// The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.
  /// When a radial area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.
  /// If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),
  /// the startAngle, endAngle, innerRadius and outerRadius accessors will subsequently be evaluated and the point will be added to the current area segment.
  /// Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.
  /// As a result, the generated area may have several discrete segments.
  /// Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.
  /// In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points
  /// being passed the element d, the index i, and the array data as three arguments.
  /*external RadialArea defined(bool defined(Datum d, num index, List<Datum> data));*/
  external dynamic /*Func3<Datum, num, List<Datum>, bool>|RadialArea*/ defined(
      [dynamic /*bool|Func3<Datum, num, List<Datum>, bool>*/ defined]);

  /// Returns the current curve factory, which defaults to curveLinear.
  /*external CurveFactory curve();*/
  /// Returns the current curve factory, which defaults to curveLinear.
  /// The generic allows to cast the curve factory to a specifc type, if known.
  /*external C curve<C extends CurveFactory>();*/
  /// Sets the curve factory and returns this radial area generator.
  /// Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.
  /*external RadialArea curve(CurveFactory curve);*/
  external dynamic /*CurveFactory|C|RadialArea*/ curve/*<C extends CurveFactory>*/(
      [CurveFactory curve]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this radial area generator.
  /// If the context is not null, then the generated radial area is rendered to this context as a sequence of path method calls.
  /*external RadialArea context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this radial area generator.
  /// A path data string representing the generated radial area will be returned when the generator is invoked with data.
  /*external RadialArea context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|RadialArea*/ context(
      [CanvasRenderingContext2D context]);

  /// Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.
  /// The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.
  external RadialLine<Datum> lineStartAngle();

  /// Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.
  /// The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.
  external RadialLine<Datum> lineInnerRadius();

  /// Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.
  /// The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.
  external RadialLine<Datum> lineEndAngle();

  /// Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.
  /// The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.
  external RadialLine<Datum> lineOuterRadius();
}

/// Constructs a new radial area generator with the default settings.
/// Ensure that the accessors used with the area generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/*external RadialArea<Tuple of <num,num>> radialArea();*/
/// Constructs a new radial area generator with the default settings.
/// Ensure that the accessors used with the area generator correspond to the arguments passed into them,
/// or set them to constants as appropriate.
/// The generic refers to the data type of an element in the input array passed into the radial area generator.
/*external RadialArea<Datum> radialArea<Datum>();*/
@JS()
external RadialArea /*RadialArea<Tuple of <num,num>>|RadialArea<Datum>*/ radialArea/*<Datum>*/();

/// -----------------------------------------------------------------------------------
/// Curve Factories
/// -----------------------------------------------------------------------------------
/// A minimal interface for a curve generator which supports only the rendering of lines.
/// Methods for related to the rendering of areas are not implemented in this minimal interface.
/// While lines are defined as a sequence of two-dimensional [x, y] points,
/// there remains the task of transforming this discrete representation into a continuous shape: i.e., how to interpolate between the points.
/// A curve generator serves this purpose.
/// Curves are typically not constructed or used directly, instead being passed to line.curve.
@anonymous
@JS()
abstract class CurveGeneratorLineOnly {
  /// Indicates the start of a new line segment. Zero or more points will follow.
  external void lineStart();

  /// Indicates the end of the current line segment.
  external void lineEnd();

  /// Indicates a new point in the current line segment with the given x- and y-values.
  external void point(num x, num y);
}

/// A factory for curve generators addressing only lines, but not areas.
/// This is a base interface to be extended, hence the suppression of the warning
/// tslint:disable-next-line:callable-types
typedef CurveGeneratorLineOnly CurveFactoryLineOnly(
    dynamic /*CanvasRenderingContext2D|Path*/ context);

/// A minimal interface for a curve generator which supports the rendering of lines and areas.
/// While lines are defined as a sequence of two-dimensional [x, y] points,
/// and areas are similarly defined by a topline and a baseline,
/// there remains the task of transforming this discrete representation into a continuous shape: i.e., how to interpolate between the points.
/// A curve generator serves this purpose.
/// Curves are typically not constructed or used directly, instead being passed to line.curve and area.curve.
@anonymous
@JS()
abstract class CurveGenerator implements CurveGeneratorLineOnly {
  /// Indicates the start of a new area segment.
  /// Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.
  external void areaStart();

  /// Indicates the end of the current area segment.
  external void areaEnd();
}

/// A factory for curve generators addressing both lines and areas.
/// This is a base interface to be extended, hence the suppression of the warning
/// tslint:disable-next-line:callable-types
typedef CurveGenerator CurveFactory(
    dynamic /*CanvasRenderingContext2D|Path*/ context);

/// A curve factory for cubic basis spline generators.
/// The curve generators produce a cubic basis spline using the specified control points.
/// The first and last points are triplicated such that the spline starts at the first point and ends at the last point,
/// and is tangent to the line between the first and second points, and to the line between the penultimate and last points.
@JS()
external CurveFactory get curveBasis;
@JS()
external set curveBasis(CurveFactory v);

/// A curve factory for closed cubic basis spline generators.
/// The curve generators produce a closed cubic basis spline using the specified control points.
/// When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.
@JS()
external CurveFactory get curveBasisClosed;
@JS()
external set curveBasisClosed(CurveFactory v);

/// A curve factory for open cubic basis spline generators.
/// The curve generators produce a cubic basis spline using the specified control points.
/// Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.
@JS()
external CurveFactory get curveBasisOpen;
@JS()
external set curveBasisOpen(CurveFactory v);

/// A curve factory for straightened cubic basis spline generators.
/// The curve generators produce a straightened cubic basis spline using the specified control points,
/// with the spline straightened according to the curve’s beta, which defaults to 0.85.
/// This curve is typically used in hierarchical edge bundling to disambiguate connections,
/// as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data.
/// This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.
@anonymous
@JS()
abstract class CurveBundleFactory implements Function/*=CurveFactoryLineOnly*/ {
  /// Returns a bundle curve factory with the specified beta in the range [0, 1], representing the bundle strength.
  /// If beta equals zero, a straight line between the first and last point is produced; if beta equals one,
  /// a standard basis spline is produced.
  external CurveBundleFactory beta(num beta);
}

/// A curve factory for straightened cubic basis spline generators.
/// The curve generators produce a straightened cubic basis spline using the specified control points,
/// with the spline straightened according to the curve’s beta, which defaults to 0.85.
/// This curve is typically used in hierarchical edge bundling to disambiguate connections,
/// as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data.
/// This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.
@JS()
external CurveBundleFactory get curveBundle;
@JS()
external set curveBundle(CurveBundleFactory v);

/// A curve factory for cubic cardinal spline generators.
@anonymous
@JS()
abstract class CurveCardinalFactory implements Function/*=CurveFactory*/ {
  /// Returns a cardinal curve factory with the specified tension in the range [0, 1].
  /// The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline.
  external CurveCardinalFactory tension(num tension);
}

/// A curve factory for cubic cardinal spline generators.
/// The curve generators produce a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece.
/// The default tension is 0.
@JS()
external CurveCardinalFactory get curveCardinal;
@JS()
external set curveCardinal(CurveCardinalFactory v);

/// A curve factory for closed cubic cardinal spline generators.
/// The curve generators produce closed cubic cardinal spline using the specified control points.
/// When a line segment ends, the first three control points are repeated, producing a closed loop.
/// The default tension is 0.
@JS()
external CurveCardinalFactory get curveCardinalClosed;
@JS()
external set curveCardinalClosed(CurveCardinalFactory v);

/// A curve factory for open cubic cardinal spline generators.
/// The curve generators produce a cubic cardinal spline using the specified control points.
/// Unlike curveCardinal, one-sided differences are not used for the first and last piece,
/// and thus the curve starts at the second point and ends at the penultimate point.
/// The default tension is 0.
@JS()
external CurveCardinalFactory get curveCardinalOpen;
@JS()
external set curveCardinalOpen(CurveCardinalFactory v);

/// A curve factory for cubic Catmull–Rom spline generators.
@anonymous
@JS()
abstract class CurveCatmullRomFactory implements Function/*=CurveFactory*/ {
  /// Returns a cubic Catmull–Rom curve factory with the specified alpha in the range [0, 1].
  /// If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero;
  /// if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline.
  /// Centripetal splines are recommended to avoid self-intersections and overshoot.
  external CurveCatmullRomFactory alpha(num alpha);
}

/// A curve factory for cubic Catmull–Rom spline generators.
/// The curve generators produce a cubic Catmull–Rom spline using the specified control points and the parameter alpha,
/// which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves,
/// with one-sided differences used for the first and last piece.
@JS()
external CurveCatmullRomFactory get curveCatmullRom;
@JS()
external set curveCatmullRom(CurveCatmullRomFactory v);

/// A curve factory for cubic Catmull–Rom spline generators.
/// The curve generators produce a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha,
/// which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends,
/// the first three control points are repeated, producing a closed loop.
@JS()
external CurveCatmullRomFactory get curveCatmullRomClosed;
@JS()
external set curveCatmullRomClosed(CurveCatmullRomFactory v);

/// A curve factory for cubic Catmull–Rom spline generators.
/// The curve generators produce a cubic Catmull–Rom spline using the specified control points and the parameter alpha,
/// which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece,
/// and thus the curve starts at the second point and ends at the penultimate point.
@JS()
external CurveCatmullRomFactory get curveCatmullRomOpen;
@JS()
external set curveCatmullRomOpen(CurveCatmullRomFactory v);

/// A curve factory for polyline generators.
/// The curve generators produce a polyline through the specified points.
@JS()
external CurveFactory get curveLinear;
@JS()
external set curveLinear(CurveFactory v);

/// A curve factory for closed polyline generators.
/// The curve generators produce a closed polyline through the specified points by repeating the first point when the line segment ends.
@JS()
external CurveFactory get curveLinearClosed;
@JS()
external set curveLinearClosed(CurveFactory v);

/// A curve factory for cubic spline generators preserving monotonicity in y.
/// The curve generators produce a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension:
/// “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations.
/// Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”
@JS()
external CurveFactory get curveMonotoneX;
@JS()
external set curveMonotoneX(CurveFactory v);

/// A curve factory for cubic spline generators preserving monotonicity in x.
/// The curve generators produce a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension:
/// “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations.
/// Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”
@JS()
external CurveFactory get curveMonotoneY;
@JS()
external set curveMonotoneY(CurveFactory v);

/// A curve factory for natural cubic spline generators.
/// The curve generators produce a natural cubic spline with the second derivative of the spline set to zero at the endpoints.
@JS()
external CurveFactory get curveNatural;
@JS()
external set curveNatural(CurveFactory v);

/// A curve factory for step function (midpoint) generators.
/// The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.
/// The y-value changes at the midpoint of each pair of adjacent x-values.
@JS()
external CurveFactory get curveStep;
@JS()
external set curveStep(CurveFactory v);

/// A curve factory for step function (after) generators.
/// The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.
/// The y-value changes after the x-value.
@JS()
external CurveFactory get curveStepAfter;
@JS()
external set curveStepAfter(CurveFactory v);

/// A curve factory for step function (before) generators.
/// The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.
/// The y-value changes before the x-value.
@JS()
external CurveFactory get curveStepBefore;
@JS()
external set curveStepBefore(CurveFactory v);

/// -----------------------------------------------------------------------------------
/// SYMBOLS
/// -----------------------------------------------------------------------------------
/// A Symbol Type.
/// Symbol types are typically not used directly, instead being passed to symbol.type.
/// However, you can define your own sumbol type implementation should none of the built-in types satisfy your needs using the following interface.
/// You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator
@anonymous
@JS()
abstract class SymbolType {
  /// Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPathMethods interface.
  /// (Note that this is a subset of the CanvasRenderingContext2D interface!)
  external void draw(Path2D context, num size);
}

/// A symbol generator.
/// Symbols provide a categorical shape encoding as is commonly used in scatterplots. Symbols are always centered at ⟨0,0⟩;
/// use a transform (see: SVG, Canvas) to move the arc to a different position.
/// The first generic corresponds to the "this" context within which the symbol generator is invoked.
/// The second generic corrsponds to the data type of the datum underlying the symbol.
@anonymous
@JS()
abstract class Symbol<This, Datum> {
  /// Generates a symbol for the given arguments.
  /// IMPORTANT: If the rendering context of the symbol generator is null,
  /// then the symbol is returned as a path data string.
  /// The "this" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.
  /// All arguments passed into this function, will be passed to the accessor functions of the generator.
  /// For example, with the default settings, no arguments are needed to produce a circle with area 64 square pixels.
  /*external String|Null call(This JS$this, [Datum d, dynamic args1, dynamic args2, dynamic args3, dynamic args4, dynamic args5]);*/
  /// Generates an symbol for the given arguments.
  /// IMPORTANT: If the symbol generator has been configured with a rendering context,
  /// then the symbol is rendered to this context as a sequence of path method calls and this function returns void.
  /// The "this" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.
  /// All arguments passed into this function, will be passed to the accessor functions of the generator.
  /// For example, with the default settings, no arguments are needed to produce a circle with area 64 square pixels.
  /*external void call(This JS$this,
    [Datum d,
    dynamic args1,
    dynamic args2,
    dynamic args3,
    dynamic args4,
    dynamic args5]);*/
  external dynamic /*String|Null*/ call(
      /*This this*/ [Datum d, List<dynamic> args]);

  /// Returns the current size accessor, which defaults to a function returning a constant value of 64.
  /*external (this: This, d: Datum, ...args: any[]) => number size();*/
  /// Sets the size to the specified number and returns this symbol generator.
  /*external Symbol size(num size);*/
  /// Sets the size to the specified function and returns this symbol generator.
  /// Specifying the size as a function is useful for constructing a scatterplot with a size encoding.
  /// If you wish to scale the symbol to fit a given bounding box, rather than by area, try SVG’s getBBox.
  /// receives the same arguments that were passed into the symbol generator.
  /*external Symbol size((this: This, d: Datum, ...args: any[]) => number size);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => number|Symbol*/ size(
      [dynamic /*num|(this: This, d: Datum, ...args: any[]) => number*/ size]);

  /// Returns the current symbol type accessor, which defaults to a function returning the circle symbol type.
  /*external (this: This, d: Datum, ...args: any[]) => SymbolType type();*/
  /// Sets the symbol type to the specified symbol type and returns this symbol generator.
  /*external Symbol type(SymbolType type);*/
  /// Sets the symbol type to the specified function and returns this symbol generator.
  /// receives the same arguments that were passed into the symbol generator. See symbols for the set of built-in symbol types.
  /// To implement a custom symbol type, return an object that implements symbolType.draw.
  /*external Symbol type((this: This, d: Datum, ...args: any[]) => SymbolType type);*/
  external dynamic /*(this: This, d: Datum, ...args: any[]) => SymbolType|Symbol*/ type(
      [dynamic /*SymbolType|(this: This, d: Datum, ...args: any[]) => SymbolType*/ type]);

  /// Returns the current rendering context, which defaults to null.
  /*external CanvasRenderingContext2D|Null context();*/
  /// Sets the rendering context and returns this symbol generator.
  /// If the context is not null, then the generated symbol is rendered to this context as a sequence of path method calls.
  /*external Symbol context(CanvasRenderingContext2D context);*/
  /// Sets the rendering context to null and returns this symbol generator.
  /// A path data string representing the generated symbol will be returned when the generator is invoked with data.
  /*external Symbol context(Null context);*/
  external dynamic /*CanvasRenderingContext2D|Symbol*/ context(
      [CanvasRenderingContext2D context]);
}

/// Constructs a new symbol generator with the default settings.
/*external Symbol<dynamic, dynamic> symbol();*/
/// Constructs a new symbol generator with the default settings.
/// The generic corrsponds to the data type of the datum underlying the symbol.
/*external Symbol<dynamic,Datum> symbol<Datum>();*/
/// Constructs a new symbol generator with the default settings.
/// The first generic corresponds to the "this" context within which the symbol generator is invoked.
/// The second generic corrsponds to the data type of the datum underlying the symbol.
/*external Symbol<This,Datum> symbol<This, Datum>();*/
@JS()
external Symbol<dynamic,
    dynamic> /*Symbol<dynamic,dynamic>|Symbol<dynamic,Datum>|Symbol<This,Datum>*/ symbol/*<Datum, This>*/();

/// An array containing the set of all built-in symbol types: circle, cross, diamond, square, star, triangle, and wye.
/// Useful for constructing the range of an ordinal scale should you wish to use a shape encoding for categorical data.
@JS()
external List<SymbolType> get symbols;
@JS()
external set symbols(List<SymbolType> v);

/// The circle symbol type.
@JS()
external SymbolType get symbolCircle;
@JS()
external set symbolCircle(SymbolType v);

/// The Greek cross symbol type, with arms of equal length.
@JS()
external SymbolType get symbolCross;
@JS()
external set symbolCross(SymbolType v);

/// The rhombus symbol type.
@JS()
external SymbolType get symbolDiamond;
@JS()
external set symbolDiamond(SymbolType v);

/// The square symbol type.
@JS()
external SymbolType get symbolSquare;
@JS()
external set symbolSquare(SymbolType v);

/// The pentagonal star (pentagram) symbol type.
@JS()
external SymbolType get symbolStar;
@JS()
external set symbolStar(SymbolType v);

/// he up-pointing triangle symbol type.
@JS()
external SymbolType get symbolTriangle;
@JS()
external set symbolTriangle(SymbolType v);

/// The Y-shape symbol type.
@JS()
external SymbolType get symbolWye;
@JS()
external set symbolWye(SymbolType v);

/// -----------------------------------------------------------------------------------
/// STACKS
/// -----------------------------------------------------------------------------------
/// Each series point j in a stack chart corresponds to the jth element in the input data.
/// Each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline);
/// the difference between y0 and y1 corresponds to the computed value for this point.
/// SeriesPoint is a [number, number] two-element Array with added data and index properties
/// related to the data element which formed the basis for theSeriesPoint
@anonymous
@JS()
abstract class SeriesPoint<Datum> implements List<num> {
  /// Correponds to y0, the lower value (baseline).
  external num get JS$0;
  external set JS$0(num v);

  /// Correponds to y1, the upper value (topline).
  external num get JS$1;
  external set JS$1(num v);

  /// The data element underlying the series point.
  external Datum get data;
  external set data(Datum v);
}

/// The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key.
/// Each series is an array of points, where each point j corresponds to the jth element in the input data.
/// The key for each series is available as series.key, and the index as series.index.
@anonymous
@JS()
abstract class Series<Datum, Key> implements List<SeriesPoint<Datum>> {
  /// Key of the series
  external Key get key;
  external set key(Key v);

  /// Index of the series in the series array returned by stack generator
  external num get index;
  external set index(num v);
}

/// A stack generator.
/// Some shape types can be stacked, placing one shape adjacent to another. For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by product category, stacking bars vertically.
/// This is equivalent to subdividing a bar chart by an ordinal dimension (such as product category) and applying a color encoding.
/// Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories, as only the bottom layer of the stack is aligned.
/// So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)
/// Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.
/// The first generic corresponds to the "this" context in which the stack generator and its accessor functions are invoked.
/// The second generic corresponds to the data type of an element in the data array passed into the stack generator.
/// The third generic corresponds to the data type of key used to identify a series.
@anonymous
@JS()
abstract class Stack<This, Datum, Key> {
  /// Generates a stack for the given array of data, returning an array representing each series.
  /// The resulting array has one element per series. Each series in then typically passed to an area generator to render an area chart,
  /// or used to construct rectangles for a bar chart.
  /// Any additional arguments are arbitrary; they are simply propagated to the generator’s accessor functions along with the this object.
  external List<Series<Datum, Key>> call(List<Datum> data,
      [dynamic args1,
      dynamic args2,
      dynamic args3,
      dynamic args4,
      dynamic args5]);

  /// Returns the current keys accessor, which defaults to the empty array.
  /*external (this: This, data: Datum[], ...args: any[]) => Key[] keys();*/
  /// Sets the keys accessor to the specified function or array and returns this stack generator.
  /// A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values.
  /// The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.
  /*external Stack keys(List<Key> keys);*/
  /// Sets the keys accessor to the specified function or array and returns this stack generator.
  /// A series (layer) is generated for each key. Keys are typically strings, but they may be arbitrary values.
  /// The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.
  /*external Stack keys((this: This, data: Datum[], ...args: any[]) => Key[] keys);*/
  external dynamic /*(this: This, data: Datum[], ...args: any[]) => Key[]|Stack*/ keys(
      [dynamic /*List<Key>|(this: This, data: Datum[], ...args: any[]) => Key[]*/ keys]);

  /// Returns the current value accessor, which defaults to a function return the property corresponding to the relevant key from the data element.
  /// Thus, by default the stack generator assumes that the input data is an array of objects, with each object exposing named properties with numeric values; see stack for an example.
  /*external Func4<Datum, Key, num, List<Datum>, num> value();*/
  /// Sets the value accessor to the specified number and returns this stack generator.
  /*external Stack value(num value);*/
  /// Sets the value accessor to the specified function and returns this stack generator.
  /// the datum, the key, index of the data element in the input data array, and the complete data array.
  /*external Stack value(num value(Datum d, Key key, num j, List<Datum> data));*/
  external dynamic /*Func4<Datum, Key, num, List<Datum>, num>|Stack*/ value(
      [dynamic /*num|Func4<Datum, Key, num, List<Datum>, num>*/ value]);

  /// Returns the current order acccesor, which defaults to stackOrderNone; this uses the order given by the key accessor.
  /*external Func1<Series<Datum, Key>, List<num>> order();*/
  /// Reset the order to use stackOrderNone; this uses the order given by the key accessor.
  /*external Stack order(Null order);*/
  /// Sets the order accessor to the specified array and returns this stack generator.
  /// The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed.
  /// The index attribute for each series is also not set until after the order is computed.
  /*external Stack order(List<num> order);*/
  /// Sets the order accessor to the specified function and returns this stack generator.
  /// The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed.
  /// The index attribute for each series is also not set until after the order is computed.
  /// See stack orders for the built-in orders.
  /*external Stack order(List<num> order(Series<Datum, Key> series));*/
  external dynamic /*Func1<Series<Datum,Key>, List<num>>|Stack*/ order(
      [dynamic /*List<num>|Func1<Series<Datum,Key>, List<num>>*/ order]);

  /// Returns the current offset acccesor, which defaults to stackOffsetNone; this uses a zero baseline.
  /*external VoidFunc2<Series<Datum, Key>, List<num>> offset();*/
  /// Reset the offset to use stackOffsetNone; this uses a zero baseline.
  /*external Stack offset(Null offset);*/
  /// Sets the offset accessor to the specified function and returns this stack generator.
  /*external Stack offset(void offset(Series<Datum, Key> series, List<num> order));*/
  external dynamic /*VoidFunc2<Series<Datum,Key>, List<num>>|Stack*/ offset(
      [void offset(Series<Datum, Key> series, List<num> order)]);
}

/// Constructs a new stack generator with the default settings.
/// Ensure that the accessors used with the stack generator correspond to the arguments passed into them.
/*external Stack<dynamic,JSMap of <String,num>,String> stack();*/
/// Constructs a new stack generator with the default settings.
/// Ensure that the accessors used with the stack generator correspond to the arguments passed into them.
/// The generic corresponds to the data type of an element in the data array passed into the stack generator.
/*external Stack<dynamic,Datum,String> stack<Datum>();*/
/// Constructs a new stack generator with the default settings.
/// Ensure that the accessors used with the stack generator correspond to the arguments passed into them.
/// The first generic corresponds to the data type of an element in the data array passed into the stack generator.
/// The second generic corresponds to the data type of key used to identify a series.
/*external Stack<dynamic,Datum,Key> stack<Datum, Key>();*/
/// Constructs a new stack generator with the default settings.
/// Ensure that the accessors used with the stack generator correspond to the arguments passed into them.
/// The first generic corresponds to the "this" context in which the stack generator and its accessor functions are invoked.
/// The second generic corresponds to the data type of an element in the data array passed into the stack generator.
/// The third generic corresponds to the data type of key used to identify a series.
/*external Stack<This,Datum,Key> stack<This, Datum, Key>();*/
@JS()
external Stack /*Stack<dynamic,JSMap of <String,num>,String>|Stack<dynamic,Datum,String>|Stack<dynamic,Datum,Key>|Stack<This,Datum,Key>*/ stack/*<Datum, Key, This>*/();

/// Returns a series order such that the smallest series (according to the sum of values) is at the bottom.
@JS()
external List<num> stackOrderAscending(Series<dynamic, dynamic> series);

/// Returns a series order such that the largest series (according to the sum of values) is at the bottom.
@JS()
external List<num> stackOrderDescending(Series<dynamic, dynamic> series);

/// Returns a series order such that the larger series (according to the sum of values) are on the inside and the smaller series are on the outside.
/// This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
@JS()
external List<num> stackOrderInsideOut(Series<dynamic, dynamic> series);

/// Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
@JS()
external List<num> stackOrderNone(Series<dynamic, dynamic> series);

/// Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
@JS()
external List<num> stackOrderReverse(Series<dynamic, dynamic> series);

/// Applies a zero baseline and normalizes the values for each point such that the topline is always one.
@JS()
external void stackOffsetExpand(
    Series<dynamic, dynamic> series, List<num> order);

/// Applies a zero baseline.
@JS()
external void stackOffsetNone(Series<dynamic, dynamic> series, List<num> order);

/// Shifts the baseline down such that the center of the streamgraph is always at zero.
@JS()
external void stackOffsetSilhouette(
    Series<dynamic, dynamic> series, List<num> order);

/// Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order.
/// See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
@JS()
external void stackOffsetWiggle(
    Series<dynamic, dynamic> series, List<num> order);

